package com.longcode.colorRecogniser.models.shallowModels.diff;

import java.util.ArrayList;
import java.util.List;

/**
 * Performs a linear time and space comparison of two objects by comparing both objects in both directions to find a
 * overlapping path which is called the middle snake.
 * <p>
 * Myers proved that the middle segment is already a part of the solution. Furthermore the middle segment divides the
 * comparison in two sub problems, which further can be compared using this technique.
 *
 * @author Roman Vottner
 * @link http://simplygenius.net/Article/DiffTutorial2
 * @link http://www.codeproject.com/Articles/42279/Investigating-Myers-diff-algorithm-Part-2-of-2
 */
public class LinearDiff
{
    /**
     * Compares two character sequences or strings with each other and calculates the shortest edit sequence (SES) as
     * well as the longest common subsequence (LCS) to transfer input <em>a</em> to input <em>b</em>. The SES are the
     * necessary actions required to perform the transformation.
     *
     * @param a
     *         The first character sequence; usually the oldest string
     * @param b
     *         The second character sequence; usually the newest string
     *
     * @return The result containing the snake that lead from input string a to input string b
     *
     * @throws Exception
     */
    public static Results<String> Compare(String a, String b) throws Exception
    {
        String[] aa = StringToArray(a);
        String[] ab = StringToArray(b);

        return Compare(aa, ab);
    }

    /**
     * Transforms a string into an array of single string characters.
     *
     * @param s
     *         The string to turn into a string array
     *
     * @return The input string transformed into an array of string characters
     */
    private static String[] StringToArray(String s)
    {
        String[] as = new String[s.length()];
        int i = 0;
        for (char c : s.toCharArray())
        {
            as[i++] = "" + c;
        }
        return as;
    }

    /**
     * Compares two arrays of type <em>T</em> with each other and calculates the shortest edit sequence (SES) as well as
     * the longest common subsequence (LCS) to transfer input <em>a</em> to input <em>b</em>. The SES are the necessary
     * actions required to perform the transformation.
     *
     * @param aa
     *         Usually the older object which should be compared
     * @param ab
     *         Usually the newest object to be compared with <em>aa</em>
     *
     * @return The result containing the snake that lead from input <em>aa</em> to input <em>ab</em>
     *
     * @throws Exception
     */
    public static <T> Results<T> Compare(T[] aa, T[] ab) throws Exception
    {
        V VForward = new V(aa.length, ab.length, true, true);
        V VReverse = new V(aa.length, ab.length, false, true);

        List<Snake<T>> snakes = new ArrayList<>();
        List<V> forwardVs = new ArrayList<>();
        List<V> reverseVs = new ArrayList<>();

        Compare(snakes, forwardVs, reverseVs, aa, aa.length, ab, ab.length, VForward, VReverse);

        return new Results<>(snakes, forwardVs, reverseVs);
    }

    /**
     * Compares two arrays of type <em>T</em> with each other and calculates the shortest edit sequence (SES) as well as
     * the longest common subsequence (LCS) to transfer input <em>a</em> to input <em>b</em>. The SES are the necessary
     * actions required to perform the transformation.
     *
     * @param snakes
     *         The possible solution paths for transforming object <em>pa </em> to <em>pb</em>
     * @param forwardVs
     *         All saved end points in forward direction indexed on <em>d</em>
     * @param reverseVs
     *         All saved end points in backward direction indexed on <em>d</em>
     * @param pa
     *         Elements of the first object. Usually the original object
     * @param N
     *         The number of elements of the first object to compare
     * @param pb
     *         Elements of the second object. Usually the current object
     * @param M
     *         The number of elements of the second object to compare
     * @param VForward
     *         An array of end points for a given k-line in forward direction
     * @param VReverse
     *         An array of end points for a given k-line in backward direction
     *
     * @throws Exception
     */
    static <T> void Compare(List<Snake<T>> snakes, List<V> forwardVs, List<V> reverseVs, T[] pa, int N, T[] pb, int M,
                            V VForward, V VReverse) throws Exception
    {
        Compare(0, snakes, forwardVs, reverseVs, pa, 0, N, pb, 0, M, VForward, VReverse);
    }

    /**
     * Compares two arrays of type <em>T</em> with each other and calculates the shortest edit sequence (SES) as well as
     * the longest common subsequence (LCS) to transfer input <em>a</em> to input <em>b</em>. The SES are the necessary
     * actions required to perform the transformation.
     *
     * @param recursion
     *         The number of the current recursive step
     * @param snakes
     *         The possible solution paths for transforming object <em>pa </em> to <em>pb</em>
     * @param forwardVs
     *         All saved end points in forward direction indexed on <em>d</em>
     * @param reverseVs
     *         All saved end points in backward direction indexed on <em>d</em>
     * @param pa
     *         Elements of the first object. Usually the original object
     * @param a0
     *         The starting position in the array of elements from the first object to compare
     * @param N
     *         The number of elements of the first object to compare
     * @param pb
     *         Elements of the second object. Usually the current object
     * @param b0
     *         The starting position in the array of elements from the second object to compare
     * @param M
     *         The number of elements of the second object to compare
     * @param VForward
     *         An array of end points for a given k-line in forward direction
     * @param VReverse
     *         An array of end points for a given k-line in backward direction
     *
     * @throws Exception
     */
    static <T> void Compare(int recursion, List<Snake<T>> snakes, List<V> forwardVs, List<V> reverseVs, T[] pa, int a0,
                            int N, T[] pb, int b0, int M, V VForward, V VReverse) throws Exception
    {
        if (M == 0 && N > 0)
        {
            // add N deletions to SES
            Snake<T> right = new Snake<>(a0, N, b0, M, true, a0, b0, N, 0, 0);
            if (snakes.size() == 0 || !snakes.get(snakes.size() - 1).append(right))
            {
                snakes.add(right);
            }
        }

        if (N == 0 && M > 0)
        {
            // add M insertions to SES
            Snake<T> down = new Snake<>(a0, N, b0, M, true, a0, b0, 0, M, 0);
            if (snakes.size() == 0 || !snakes.get(snakes.size() - 1).append(down))
            {
                snakes.add(down);
            }
        }

        if (N <= 0 || M <= 0)
        {
            return;
        }

        //calculate middle snake
        SnakePair<T> m = LCS.MiddleSnake(pa, a0, N, pb, b0, M, VForward, VReverse, forwardVs, reverseVs);

        // Initial setup for recursion
        if (recursion == 0)
        {
            if (m.getForward() != null)
            {
                m.getForward().setMiddlePoint(true);
            }
            if (m.getReverse() != null)
            {
                m.getReverse().setMiddlePoint(true);
            }
        }

        // check for edge (D = 0 or 1) or middle segment (D > 1)
        if (m.getD() > 1)
        {
            // solve the rectangles that remain to the top left and bottom right

            // top left .. Compare(A[1..x], x, B[1..y], y)
            Pair<Integer> xy = (m.getForward() != null ? m.getForward().getStartPoint() : m.getReverse().getEndPoint());
            Compare(recursion + 1, snakes, null, null, pa, a0, xy.X() - a0, pb, b0, xy.Y() - b0, VForward, VReverse);

            // add middle snake to results
            if (m.getForward() != null)
            {
                if (snakes.size() == 0 || !snakes.get(snakes.size() - 1).append(m.getForward()))
                {
                    snakes.add(m.getForward());
                }
            }
            if (m.getReverse() != null)
            {
                if (snakes.size() == 0 || !snakes.get(snakes.size() - 1).append(m.getReverse()))
                {
                    snakes.add(m.getReverse());
                }
            }

            // bottom right .. Compare(A[u+1..N], N-u, B[v+1..M], M-v)
            Pair<Integer> uv = (m.getReverse() != null ? m.getReverse().getStartPoint() : m.getForward().getEndPoint());
            Compare(recursion + 1, snakes, null, null, pa, uv.X(), a0 + N - uv.X(), pb, uv.Y(), b0 + M - uv.Y(),
                    VForward, VReverse);
        }
        else
        {
            // we found an edge case. If d == 0 than both segments are identical
            // if d == 1 than there is exactly one insertion or deletion which
            // results in a odd delta and therefore a forward snake
            if (m.getForward() != null)
            {
                // add d = 0 diagonal to results
                if (m.getForward().XStart > a0)
                {
                    if (m.getForward().XStart - a0 != m.getForward().YStart - b0)
                    {
                        throw new Exception("Missed D0 forward");
                    }
                    Snake<T> snake = new Snake<>(a0, N, b0, M, true, a0, b0, 0, 0, m.getForward().XStart - a0);
                    if (snakes.size() == 0 || !snakes.get(snakes.size() - 1).append(snake))
                    {
                        snakes.add(snake);
                    }
                }

                // add middle snake to results
                if (snakes.size() == 0 || !snakes.get(snakes.size() - 1).append(m.getForward()))
                {
                    snakes.add(m.getForward());
                }
            }

            if (m.getReverse() != null)
            {
                // add middle snake to results
                if (snakes.size() == 0 || !snakes.get(snakes.size() - 1).append(m.getReverse()))
                {
                    snakes.add(m.getReverse());
                }

                // D0
                if (m.getReverse().XStart < a0 + N)
                {
                    if (a0 + N - m.getReverse().XStart != b0 + M - m.getReverse().YStart)
                    {
                        throw new Exception("Missed D0 reverse");
                    }
                    Snake<T> snake = new Snake<>(a0, N, b0, M, true, m.getReverse().XStart, m.getReverse().YStart, 0, 0,
                                                 a0 + N - m.getReverse().XStart);
                    if (snakes.size() == 0 || !snakes.get(snakes.size() - 1).append(snake))
                    {
                        snakes.add(snake);
                    }
                }
            }
        }
    }
}
